# Lesson 3: Making Open Code

## Overview

In this lesson, you will learn about the practical steps to make code openly available. Large volume and well-established software have different needs than an incipient project. For example, a script written to create a simple plot has different requirements than a software package that models the Earth's climate. The size of a research team can also determine the steps required to make code open access. This lesson covers the process to make code usable to other researchers through documentation, considerations around licenses, and software development best practices.

## Learning Objectives

After completing this lesson, you should be able to:

- Describe the key considerations when planning a new open software project.
- List three reasons for projects to use version control.
- Explain the purpose and recall general information typically included in a README file.
- Be able to select a license for your code and list the differences between permissive and protective open-source software licenses.
- Explain best practices in software development that support transparency, reproducibility and collaboration.

## How do We Plan for Making Code?

Code is written to solve a challenge. This can range from producing a plot, to data-processing Earth observations, to modeling the Universe. The challenges associated with writing code can differ in difficulty as well, from simpler tasks such as the use of spreadsheets, or more complex activities like the creation of extensive libraries and use of high-performance cloud computing. Code can be developed as an individual, team, or a community. Once written, code might be used for decades or only for a specific research query.

When starting a research project, it is useful to consider the following questions:

1. What problem am I trying to solve, and are others in my scientific community facing it as well?
2. Are there existing solutions? (In Lesson 2, we explored how to look for existing solutions.)
3. Did you find code that was close to what you wanted but didn't quite meet your needs?

You could potentially contribute to existing code rather than writing something new.

Though, even if a solution already exists, there may be good reasons to develop your own code. Instances include:

- The code is written in a different programming language than you are familiar with.
- The license is not open enough to adopt it.
- To try new techniques or to develop a deeper understanding of the problem.

<SingleFigure size='small' src="./images/clone/Module_4/new/image333.jpg" />

It might take more time to start a new project or integrate someone else's code rather than writing your own. You will have to make that call.

For the purposes of this lesson, let's pretend that we are working on a research project and that we've looked for existing code. Although we found a few available options, we've decided that our needs are unique enough that nothing available will support our work. We will need to start a new project!

### Starting a New Project

When starting a new project, consider these key elements:

1. Define the project scope, its primary features and any limitations, and the intended audience.
2. Consider resources required for the software to run. Will it be on a personal computer, a high-performance computing server, or on the cloud?
3. How will it be managed?

This lesson focuses predominantly on the question of how to manage open access code.

Who will be working on the project? What are some of the development best practices? How will you share the project openly? How will it be licensed?

### Organizing a Project

<SingleFigure size='small' src="./images/clone/Module_4/new/image353.png" caption='Source: https://xkcd.com/1459/' link='https://xkcd.com/1459/' />

Software projects can be organized in a variety of ways, each of which involve unique considerations for how to begin. Many projects start out as a single script that was only intended for a one-time use. However, a script can grow into a much larger project with unforeseen applications in its original, or new, field of research. Other projects can start with formal requirements and standards.

**Making code public has many advantages:**

- It enables open collaboration
- It invites constructive feedback that contributes to a code's accuracy and robustness
- Those with less programming experience can learn from those with more programming experience as they improve the code
- It provides an intermediate product that can still be cited

When naming a project, conduct a quick search of the envisioned name to see what shows up. Avoid names with many other uses as this will make it difficult for others to discover the code. Also, do not choose embarrassing, unprofessional, or trademarked names.

Hosting the product on a version control platform ensures the permanence of your project. If the code only exists on your computer, it may disappear if the computer is damaged or is lost. 

Documenting the production and management of your code benefits both you and those that might use your code in the future. You are your own best collaborator. Documentation can save you from a future headache should you reuse the code in six months or attempt to recall meticulous details about your process later on.

**Questions to consider when choosing a programming language:**

- Will potential collaborators be able to contribute in the chosen language?
- Which languages are you most experienced with?
- Are there any limitations from your computing environment that would impede your ability to write or manage this code?
- Languages have strengths and weaknesses; which is more important to consider for your project?

**Before someone else can use your code, they will likely ask these questions:**

- Where can I find your code?
- Is your code documented?
- In what ways am I allowed to use your code?
- Will you accept changes to your code? If I find a bug, what do I do?
- How do I trust that your code works?
- How do I know if the code will be supported long-term?

## Importance of Version Control

Your code will change significantly over the lifetime of your project. Just as we can appreciate the ability to track earlier versions of documents or versions created by different people, inevitably someone will want to be able to revert, compare, and synthesize changes in code.

The most popular tool for version control is Git, a system that tracks changes in computer files. It's similar to Google Docs or SharePoint, but more applicable to code script. Git is usually used in conjunction with a version control platform such as GitHub, GitLab, or Bitbucket. These tools were covered in Module 2 (General Tools for Open Science).

Version control enables the following:

- Helps developers keep track of changes to a project's code (as well as supplemental files and documentation) over the entire course of a project's evolution.
- Revisions to a project's files can be tracked, including contributions made by different people.
- Undesirable changes (like errors or bugs) can be reverted at any time.

Version control is a good practice for coding, even if you are not immediately sharing the code. You can use version control with your code privately on your computer, or use the private mode on hosting services (e.g. GitHub and GitLab). By setting up version control early on, you prepare your code for intended and unforeseen future use.

<Definitions>
  <Definition title='Further Resources on Version Control'>
    <ul>
      <li><a href="https://swcarpentry.github.io/git-novice/">Software Carpentry Version Control with Git</a></li>
      <li><a href="https://the-turing-way.netlify.app/reproducible-research/vcs.html">The Turing Way, Version Control</a></li>
      <li><a href="https://fair-software.eu/recommendations/repository/">Use a publicly available repository with version control: guidance for FAIR software</a></li>
    </ul>
  </Definition>
</Definitions>

## Describing Our Code to Others

### README

The first stop for a user when they approach a new project should be the README file. Aptly named, this file contains orientation information that will help a user understand a project's purpose, provides examples for how it can be used, and lists other important information that the creator deems pertinent.

At the minimum, a README should contain the name of the project and a very short paragraph of what the software is. It should be limited to two to three sentences in a plain-language style that does not make assumptions about the reader. After all, it's the elevator pitch for the project.

<MultiSlider infinite={false}>
  <SliderItem type="multi">
    <h3><strong className="text-danger">Bad</strong> README example</h3>
    <p>"This code recomputes the fundamental permutation factor of the downward flow (for J < 10, obviously)."</p>
  </SliderItem>
  <SliderItem type="multi">
    <h3><strong className="text-success">Good</strong> README example</h3>
    <p>"LeapKitten. This Python software package takes any picture of a kitten (JPEG, PNG) and uses artificial intelligence to output what it would look like leaping into the air. In addition, the code takes leap years into account on the timestamp on the image."</p>
  </SliderItem>
</MultiSlider>

In addition, the following information is helpful to add to the README, especially if they are not listed elsewhere:

- A list of any code dependencies the software has, e.g. "Numpy, kitten-rng, and human-readable must be installed to run this software."
- How to install and a brief description of how to run the software.
- Detailed description of the software, especially if there is no external documentation.
- Examples of how to use the software.
- Acknowledgement of team members or sources of support.

As seen in these examples, README files can be useful for a [collection of scripts supporting a publication](https://github.com/granttremblay/Tremblay2018_Code) or an [extensively developed software package](https://github.com/MillionConcepts/lhorizon).

### Contributor Guidelines

The _**CONTRIBUTING**_ file gives information about how to contribute to the project. It details how the contribution process works and what type of contributions are needed. While not every project has a _**CONTRIBUTING**_ file, the existence of one is a clear indicator that contributions are welcomed.

You'll need to decide for yourself when your project has progressed enough to consider inviting contributors. When it has reached that point, create a document called _**CONTRIBUTING**_ at the top level of your report.

The [Astropy contributing guidelines](https://github.com/astropy/astropy/blob/main/CONTRIBUTING.md) and [Numpy contributing guidelines](https://numpy.org/devdocs/dev/index.html) provide two examples.

<InfoBox message='Bonus Tip: Even if you are developing your code publicly, this does not mean you have to accept contributions from others or maintain your code forever. The contributing guidelines or README are a good places to indicate what your expectations are for your code. This can clarify that the code is not maintained or not accepting contributions.'/>

### Code of Conduct

The code of conduct sets ground rules for participants' behavior and helps to facilitate a friendly, welcoming environment. While not every project has a _**CODE_OF_CONDUCT**_ file, its presence signals that this is a welcoming project to contribute to.

### Code Documentation

**Code Level Documentation for the Developer**

Your software should be documented within the source code. Each function should have comments at the start that briefly state, in plain language, what the function is for. This is not only for other developers, but for your future self if you've forgotten those details.

<Definitions>
  <Definition title='Example'>
    <p># This function takes the image array and crops it from the center to 50% of the original size.</p>
    <p>Without going into details of the data type, calling parameters, etc., this description immediately puts someone looking at the code into the context of what the function aims to accomplish. They can then explore the details.</p>
    <p>While you should consider placing a description at the start of a function, use your discretion on where you put similar descriptions of code. At the start of a complex loop or analysis would be a good idea. Don't go overboard - things like this aren't useful:</p>
    <p># set x to 17 </p>
    <p>x = 17</p>
    <p>Descriptive variable, class, and function names can make your code very readable. Sometimes even great coders will work fast and will name variables 'a', 'temp', or other unclear names that probably won't make a lot of sense in a week or two when they come back to something they were working on. Names like 'baking_time' or 'velocity' are more clear. Variable names should be easy to understand and clearly represent what they are.</p>
    <p>Ideally, someone who doesn't write in the software language of the code should be able to read the comments in the file and have a rough idea of what is happening.</p>
    <p>Use the comments to put URLs that reference the code and/or software you implement, such as an algorithm (e.g. Stack Overflow) or a formula from a journal paper.</p>
  </Definition>
</Definitions>

### Code Level Documentation for the User

If you are developing code that you expect others to use, produce a manual on how to use the code. As code constantly develops, it is much easier to document while, or even before, you write any code.

If you write your documentation within the code itself, there are pieces of software that can then extract the code, format it, and then present it as a polished manual. Examples of documentation generated from the code can be seen for [Astropy](https://docs.astropy.org/en/latest/) or [NumPy](https://numpy.org/doc/stable/).

They look fancy, but very similar too. These sites were completely generated from comments and documents written in the source code. Different from the comments written for developers of the code above, these comments were written specifically for the audience of external users of the code: they are the user manual.

While there are multiple software packages for automatic documentation generation, the most commonly ones used are [Sphinx](https://www.sphinx-doc.org/en/master/) for Python and [D](https://www.doxygen.nl/index.html)[oxygen](https://www.doxygen.nl/index.html) for almost everything else. [M](https://www.markdownguide.org/)[arkdown](https://www.markdownguide.org/) is also a popular choice for the formatting language for documentation.

### Programming and Documenting

<Definitions>
  <Definition title='Establishing a Development Environment'>
    <p>Establishing an appropriate development environment will help you write good, clean code and will help you maintain the project as it evolves.</p>
    <ul>
      <li>Configure any necessary tools for writing the code. Perhaps an IDE (Integrated Development Environment) or text editor. Some popular examples include VS Code, Pycharm, R Studio, and Xcode.</li>
      <li>Set up a package manager. For example, for Python, one could use 'anaconda' or 'poetry.'</li>
      <li>Create a virtual environment specific to your project to isolate its dependencies (and their versions) from those used for other projects.</li>
    </ul>
  </Definition>
  <Definition title='Structuring Files and Folders'>
    <p>Start your work in an organized manner. How you structure the files in your project will contribute to the success of the final results.</p>
    <p>Different programming languages have different standard folder structures. Familiarize yourself with the standards before starting as it will help others collaborate and will likely save you from difficulties later.</p>
    <p>There are a variety of sample code structures that can be used to get started. For example, for Python there is Cookiecutter and an Astropy package template.</p>
  </Definition>
</Definitions>

## What License Should We Choose for Our Code?

### Licensing Considerations when Using Open Software

<SingleFigure size='small' src="./images/clone/Module_4/new/book.png" />

Open source software licenses are the basis for how scientists use, make, and share code and software. Understanding some of the nuances of these licenses is important because it will affect how your project can license and share code.

A software license is a legal document that states the rights of the developer and user of a piece of software.

An open source license is a type of software license, approved by the Open Source Initiative (OSI) as compliant with the [Open Source Definition](https://opensource.org/osd). An open source license grants permissions for anyone to inspect, use, modify, and distribute the software's source code for any purpose.

Licenses ensure that developers receive credit and control over how their work is used. Without a license, software is assumed copyrighted and without permission. Programmers include licenses to allow reuse.

Licenses take various forms in order to outline:

- Contractual obligations (if any exist) between the developer and user.
- What the user may do with the software.
- To whom the user may distribute the software (if any such right exists).
- Length of time the user has the right to use the software.

### Some Common Types of Software Licenses

*Click '+' to travel more information.*

<SpectrumImage src='./images/clone/Module_4/new/spectrum-of-openness.png'>
  <SpectrumDot hPos='21.5%' vPos='65%'>
    <strong>Public Domain</strong>
    <p>Anyone is free to use.</p>
  </SpectrumDot>
  <SpectrumDot hPos='32.5%' vPos='65%'>
    <strong>Lesser General Domain</strong>
    <p>Can link to open source libraries; code can be licensed under any license type.</p>
  </SpectrumDot>
  <SpectrumDot hPos='43.5%' vPos='65%'>
    <strong>Permissive</strong>
    <p>Gives users wide latitude to reuse/re-license.</p>
  </SpectrumDot>
  {/* <SpectrumDot hPos='54.5%' vPos='65%' orientation='right'>
    <strong>Non-permissive</strong>
    <p>Allows users to reuse, but also gives users the responsibility to share their changes with the community.</p>
  </SpectrumDot> */}
  <SpectrumDot hPos='65.5%' vPos='65%' orientation='right'>
    <strong>Copyleft</strong>
    <p>Allows users to reuse, but also gives users the responsibility to share their changes with the community.</p>
  </SpectrumDot>
  <SpectrumDot hPos='76.5%' vPos='65%' orientation='right'>
    <strong>Proprietary</strong>
    <p>Cannot be copied, modified, or distributed.</p>
  </SpectrumDot>
</SpectrumImage>

<Definitions>
  <Definition title='Public Domain'>
    <p>Anyone is free to use.</p>
  </Definition>
  <Definition title='Lesser General Domain'>
    <p>Can link to open source libraries; code can be licensed under any license type.</p>
  </Definition>
  <Definition title='Permissive'>
    <p>Gives users wide latitude to reuse/re-license.</p>
  </Definition>
  <Definition title='Copyleft'>
    <p>Allows users to reuse, but also gives users the responsibility to share their changes with the community.</p>
  </Definition>
  <Definition title='Proprietary'>
    <p>Cannot be copied, modified, or distributed.</p>
  </Definition>
</Definitions>

Before you choose a license, first check with your organization or employer. They may have specific guidelines about what software license you are allowed to use. Your research grant may also stipulate permissible license types. The software management plan should specify what license you plan to use.

If a license is not shared with a code, a creative work is assumed to be copyrighted by [default in the United States](https://www.copyright.gov/help/faq/faq-general.html). It does not need to be registered, and it is assumed to be automatically protected by copyright the moment it is created.

For software, the license is shared in a file called LICENSE at the top of the repository. It's a standard location people will know to check. It's not bad practice to put a one-line version of the license at the top of each file of code as well, with a pointer to where one can find the full license.

### Types of Open-Source Software Licenses

There are two main types of open-source licenses: permissive and protective (sometimes referred to as copy-left). The difference in these types of licenses is primarily related to the type of license that users are allowed to apply to their derivative works.

<CustomTabs>
    <Tab eventKey="one" title="PERMISSIVE LICENSE">
      <p>The Open Source Initiative defines a permissive software license as a license that guarantees the freedoms to use, modify, redistribute, and create derivative works. An example of this type of license is the Apache 2.0 license by the Apache Software Foundation. It is the most popular and widely-used permissive license.</p>
      <p>Users have wide latitude for reuse under this license. They are generally free to incorporate the code into their project or use it how they wish. A user of permissive-license open source in a product could redeploy the open source software with a wide range of licenses, including proprietary closed source software.</p>
    </Tab>
    <Tab eventKey="two" title="PROTECTIVE LICENSE">
      <p>Protective (copy-left) licenses are a legal technique of granting certain freedoms over copies of copyrighted works with the requirement that the same rights be preserved in derivative works. This allows users to reuse the work, but it also requires users to share their changes with the community using the same license. An example of a protective license is the General Public License (GPL), which ensures users have the freedom and responsibility to share their changes with the community. It is the most widely-used protective license. These types of licenses can result in less reuse by users who may prefer or be required to only use permissive licenses.</p>
    </Tab>
</CustomTabs>

### Common Licenses for Open Software

Some of the most popular licenses used in open software are:

<CustomTabs>
    <Tab eventKey="one" title="PERMISSIVE">
      <p><strong>(CAN APPLY ANY LICENSE TO DERIVATIVE WORKS)</strong></p>
      <ul>
        <li><a href="https://opensource.org/license/apache-2-0/">Apache License</a></li>
        <li><a href="https://opensource.org/license/mit/">MIT License</a></li>
        <li><a href="https://opensource.org/license/bsd-3-clause/">BSD License</a></li>
      </ul>
    </Tab>
    <Tab eventKey="two" title="PROTECTIVE/ COPYLEFT">
      <p><strong>(ALL DERIVATIVE WORKS MUST DISTRIBUTE ALL ITS SOURCE CODE UNDER THE SAME LICENSE)</strong></p>
      <ul>
        <li>GNU General Public License (<a href="https://opensource.org/license/gpl-2-0/">GPL</a>)</li>
        <li><a href="https://opensource.org/license/mpl-2-0/">Mozilla</a> Public License</li>
        <li>Common Development and Distribution License (<a href="https://opensource.org/license/cddl-1-0/">CDDL</a>)</li>
      </ul>
    </Tab>
</CustomTabs>

For more information on different types of licenses, please refer to the [Open Source Initiative (OSI)](https://opensource.org/licenses/category).

### Activity 3.1: Licenses

In this activity, you are asked to answer whether the following statements are true or false:

<SimpleQuiz id="quiz-m4-l3-activity-3-1">
  <SingleChoice question="Statement 1: A software license states the rights of the developer and user for a piece of software." answer='answer-1' isBool="true">
    <SingleAnswer text='True' id='answer-1'/>
    <SingleAnswer text='False' id='answer-2'/>
  </SingleChoice>
  <SingleChoice question="Statement 2: Without a license, software is assumed copyrighted and without permissions." answer='answer-1' isBool="true">
    <SingleAnswer text='True' id='answer-1'/>
    <SingleAnswer text='False' id='answer-2'/>
  </SingleChoice>
  <SingleChoice question='Statement 3: Anyone is free to use software with a "permissive" license with minimal restrictions.' answer='answer-2' isBool="true">
    <SingleAnswer text='True' id='answer-1'/>
    <SingleAnswer text='False' id='answer-2'/>
  </SingleChoice>
  <SingleChoice question='Statement 4: Users are not allowed to copy and modify any software with a copy-left license.' answer='answer-2' isBool="true">
    <SingleAnswer text='True' id='answer-1'/>
    <SingleAnswer text='False' id='answer-2'/>
  </SingleChoice>
</SimpleQuiz>

## Programming Best Practices

In this section, you will learn some developmental phase best practices related to code review, testing, security, and availability. These best practices will improve the quality of code, reproducibility of results, and security of a project. Combined, these actions help improve the robustness of open access code and help to meet the unique challenges that can arise with multiple contributors and revisions that occur over an extended period of time.

### Code Review

Code benefits from peer review in the same way as science. Having someone else read over your code and test it can be one of the best ways to improve the quality of the code.

Many version control platforms have built-in tools that enable developers to review, comment, and iterate on each other's code. These can be done in the open and allow anyone to comment.

Here is a great example of the discussion that can happen when the original creator of an algorithm [comments on a Python implementation made by a first-time contributor to the Astropy project](https://github.com/astropy/astropy/pull/4301). The open and constructive discussion led to a better implementation of the algorithm along with possible future improvements.

Software packages can be reviewed as their own products as well. Many scientific publications now accept papers focused on software. There are entities like [PyOpenSci](https://www.pyopensci.org/about-peer-review/index.html) and the <i>[Journal of Open Source Software](https://joss.theoj.org/)</i> that provide open peer review of scientific packages. See more details about JOSS in the next lesson on sharing your code.

### Testing

A proven method to evaluate the reproducibility of your software is through testing. There are many types of testing, ranging from testing the smallest parts of a code to verifying if a code works as a whole under different scenarios. Code testing can include a wide range of different techniques. The following section provides only a brief introduction to the topic.

The main objective of code testing is to evaluate if a code does what its authors intended it to do. Comprehensively testing code can be very difficult as it involves testing the code for generating expected outputs as well as for failing when it should.

<CustomTabs>
    <Tab eventKey="one" title="SCIENTIFIC VALIDATION">
      <p>Whether producing a script or an entire data processing pipeline, the validation of software is critical to ensuring the quality and trustworthiness of the scientific results. This could mean manually calculating the results to check the output of the code, comparing it to previously-produced results, or even having another team member test it.</p>
    </Tab>
    <Tab eventKey="two" title="REPRODUCIBILITY TESTING">
      <p>Given the same inputs and parameters, can the same results be produced? Making the configuration files, input data, etc. openly available so users can easily run and produce the same published results is a critical way to increase trust in your code.</p>
    </Tab>
    <Tab eventKey="three" title="BUILT IN TESTS">
      <p>Unit tests enable software developers to bolster their confidence in their code's ability to perform as expected. Unit tests are small functions that sit outside the code base and test a specific function or run a specific test. For example, if a function takes an image and flips it horizontally, one test might check that the resulting image is the same size. Another compares the output using a known image with the expected result. Another checks that a new image is returned.</p>
    </Tab>
    <Tab eventKey="four" title="AUTOMATED TESTING">
      <p>Built-in tests can usually be run both manually and automatically. Most version control platforms offer services for running tests automatically. When run this way, code can be checked to see if changes raise any issues. This process of checking the code automatically as it is developed is called continuous development or continuous integration (CD/CI). If a small change made in one part of the code results in an unexpected change in another part, running the tests will uncover this immediately.</p>
    </Tab>
</CustomTabs>

### Minimizing the Risk of Security Vulnerabilities

Whether using open source, closed source, or commercial software, it is important to consider the security risks inherent in the development of software.

- Ensure minimal, DRY (Don't Repeat Yourself) code - this is easier to maintain and fix.
- Use global variables or key managers for credentials. Never include credentials in your code.
- Use well-tested and maintained dependencies in packages that you maintain. Keep the list of dependencies up to date.
- Create software with tools that provide automated scanning and auditing.
- If there are unsupported dependencies that you rely on, assess them to determine how they might introduce security risks and whether it would be appropriate to switch to a different package.

<CustomTabs>
    <Tab eventKey="one" title="SECURITY TOOLS AND SECURITY VULNERABILITIES">
      <p>Commercial and open source tools have been developed to address the challenge of identifying the security vulnerabilities in different source components. If you do not have any technology to secure your open-source usage, you can consider using the Dependabot or <a href="https://owasp.org/">OWASP</a> dependency check tools.</p>
      <p>The Open Web Application Security Project (OWASP), is an online community that produces free tools and technologies in the field of web application security. OWASP dependency check is a utility created for developers, which identifies project dependencies and checks if they contain any known, publicly disclosed, open source vulnerabilities.</p>
    </Tab>
    <Tab eventKey="two" title="TEST COMPONENTS AND DEPENDENCIES">
      <p>Testing the security of the open source components you are using is the best way to ensure the safety of your applications and your organization. Your commitment to timely and frequent analysis of open source components should be the same as to your proprietary code.</p>
      <p>This is especially true as the component in question may have unknown security vulnerabilities or dependencies that differ with each use case. It is possible for a component to be secure in a particular application but vulnerable in another.</p>
    </Tab>
</CustomTabs>

### Creating FAIR Software

<CustomTabs>
    <Tab eventKey="one" title="FINDABLE">
      <p>Software includes a persistent and unique identifier and rich metadata, so it is easy for humans and machines to find.</p>
    </Tab>
    <Tab eventKey="two" title="ACCESSIBLE">
      <p>Software is retrievable from its identifier via standard communication protocols.</p>
    </Tab>
    <Tab eventKey="three" title="INTEROPERABLE">
      <p>Software interoperates with other software; it exchanges data and/or metadata via community standards.</p>
    </Tab>
    <Tab eventKey="four" title="REUSABLE">
      <p>Fully described metadata with provenance, meeting community standards. License permits reuse.</p>
    </Tab>
</CustomTabs>

### Additional Helpful Tips

Here are some further suggestions on how to make your code more openly available, reproducible, and transparent:

<Definitions>
  <Definition title='Descriptive Names'>
    <p>Variables, functions, and similar entities should be given descriptive names as opposed to vague names. Descriptive names instantly give other programmers an idea of what the variable or function is. For example, the variable name <strong>colourOfCat</strong> is a good name because it describes what it intends to do, which is to encompass the color of a cat.</p>
  </Definition>
  <Definition title='Metadata File'>
    <p>Consider including a metadata file for your software to make it more discoverable. A 'codemeta.json' can be created using <a href="https://codemeta.github.io/codemeta-generator/">Code Meta's generator</a> to include with your package.</p>
  </Definition>
  <Definition title='Operation Documentation'>
    <p>Share details about how you are running the code. For example, document the version of a software library you are using, or the version of the compiler. These are often shared in an 'environment.yml' file.</p>
  </Definition>
  <Definition title='Automation'>
    <p>Consider the following scenario:</p>
    
    <p>You are getting ready to publish your paper that includes seventeen plots that all depend on a dataset released by a mission. Right before you are about to submit, the mission releases an updated version of the dataset.</p>
    
    <p>How easy will it be to recreate those plots?</p>
    
    <p>Software allows you to automate the running of scripts and alert programmers when written so that input files are not hardcoding. This allows programmers to easily rerun code if an initial parameter changes.</p>
  </Definition>
  <Definition title='Using Standards'>
    <p>Most languages have their own coding style adopted by their respective scientific communities. Following those conventions makes it easier for others to contribute to your code and makes your project more collaborative.</p>
  </Definition>
  <Definition title='Portability'>
    <p>Allows individuals the ability to transfer their personal data between platforms.</p>
  </Definition>
  <Definition title='Naming'>
    <p>Many historical terms used in software have negative connotations depending on the context. When considering different terms or naming, consider how different audiences may react to those terms.</p>
  </Definition>
</Definitions>

## Lesson 3: Summary

In this lesson, you learned:

- Planning a new project requires programmers to define a clear purpose, acknowledge any resource limitations, and envision a data management plan.
- Using a repository with version control allows developers to track changes across time and from multiple contributors, which can help with troubleshooting for errors and with managing a team of programers.
- A README file should include the name of a project and a short but clear description of the software.
- Licenses ensure that developers receive credit and control over how their work is used. Without a license, software is assumed copyrighted and without permissions.
- Testing, labeling, and implementing security measures are examples of programming best practices that support open science.

In addition to learning how to share your code in the next lesson, you will also have some opportunities to put this lesson into practice.

## Lesson 3: Knowledge Check

Answer the following questions to test what you have learned so far.

<SimpleQuiz id="quiz-m4-l3-knowledge-check">
  <MultipleChoice question='Which of the following should be considered when planning an open software project?'>
    <MultipleAnswer text='The intended user audience.' id='answer-1' isAnswer='true'/>
    <MultipleAnswer text='What protocol will be used to sync changes between individual contributors and the central repository.' id='answer-2' isAnswer='false'/>
    <MultipleAnswer text='The programming language to be used.' id='answer-3' isAnswer='true'/>
    <MultipleAnswer text='Who will financially benefit from sales of the software.' id='answer-4' isAnswer='false'/>
  </MultipleChoice>
  <SingleChoice question="Which of the following is a benefit of using a version control system in your software?" answer='answer-4'>
    <SingleAnswer text='New changes are automatically tracked.' id='answer-1'/>
    <SingleAnswer text='Different contributors can add or edit code at the same time.' id='answer-2'/>
    <SingleAnswer text='Undesirable changes can be quickly reverted.' id='answer-3'/>
    <SingleAnswer text='All of the above.' id='answer-4'/>
  </SingleChoice>
  <MultipleChoice question='Select two items that are good to include in a README file from the list below:'>
    <MultipleAnswer text='Installation/compilation instructions' id='answer-1' isAnswer='true'/>
    <MultipleAnswer text='Code development history' id='answer-2' isAnswer='false'/>
    <MultipleAnswer text='The most important portions of the code' id='answer-3' isAnswer='false'/>
    <MultipleAnswer text='Usage instructions and example output' id='answer-4' isAnswer='true'/>
  </MultipleChoice>
  <SingleChoice question="Which of the following licenses allows users to reuse, but also requires users to share their changes with the community using the same license?" answer='answer-4'>
    <SingleAnswer text='Public Domain' id='answer-1'/>
    <SingleAnswer text='Lesser general domain' id='answer-2'/>
    <SingleAnswer text='Permissive' id='answer-3'/>
    <SingleAnswer text='Protective License' id='answer-4'/>
    <SingleAnswer text='Commercial' id='answer-5'/>
  </SingleChoice>
  <MultipleChoice question='Which of the following practices can help enhance collaboration within your project?'>
    <MultipleAnswer text='Including a Code of Conduct.' id='answer-1' isAnswer='true'/>
    <MultipleAnswer text='Referencing historical events in the name of your project.' id='answer-2' isAnswer='false'/>
    <MultipleAnswer text='Following standards for the programming language being used.' id='answer-3' isAnswer='true'/>
    <MultipleAnswer text='Developing the project privately.' id='answer-4' isAnswer='false'/>
    <MultipleAnswer text='Including a Guideline for Contributors.' id='answer-5' isAnswer='true'/>
  </MultipleChoice>
</SimpleQuiz>

<CompletionDocked/>